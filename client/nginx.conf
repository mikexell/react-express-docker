# client/nginx.conf
# =================================================================
# NGINX CONFIGURATION FOR REACT SPA + API PROXY
# =================================================================
# This configuration file tells nginx how to:
# 1. Serve static React files (HTML, CSS, JS)
# 2. Handle client-side routing (React Router)
# 3. Proxy API requests to backend container
# 4. Optimize performance with compression
# =================================================================

# =================================================================
# SERVER BLOCK
# =================================================================
# A server block defines a virtual server
# You can have multiple server blocks for different domains/ports
server {
    # =============================================================
    # LISTEN DIRECTIVE - Port Configuration
    # =============================================================
    # Tell nginx to listen for HTTP requests on port 80
    # Port 80 is the default HTTP port (like :80 in URLs)
    # 
    # WHAT THIS MEANS:
    # - Container accepts connections on port 80
    # - You map this to host port: docker run -p 80:80
    # - Then access via: http://localhost (port 80 is implicit)
    #
    # FOR HTTPS (production):
    # listen 443 ssl;
    # ssl_certificate /path/to/cert.pem;
    # ssl_certificate_key /path/to/key.pem;
    listen 80;

    # =============================================================
    # SERVER NAME - Virtual Host Identifier
    # =============================================================
    # Defines which domain names this server block responds to
    # 
    # CURRENT SETTING:
    # localhost = responds to http://localhost requests
    #
    # FOR PRODUCTION:
    # server_name yourdomain.com www.yourdomain.com;
    # Multiple domains can share same configuration
    #
    # WILDCARD EXAMPLES:
    # server_name *.yourdomain.com;
    # server_name .yourdomain.com; (matches yourdomain.com and *.yourdomain.com)
    server_name localhost;

    # =============================================================
    # ROOT & INDEX - Static File Configuration
    # =============================================================
    
    # root: Base directory for serving files
    # nginx looks for files relative to this path
    # Example: request for /style.css → nginx serves /usr/share/nginx/html/style.css
    #
    # WHY THIS PATH?
    # - Standard nginx location for static content
    # - Our Dockerfile copies built files here: COPY --from=build /app/dist /usr/share/nginx/html
    # - Contains: index.html, assets/*, and all built React files
    root /usr/share/nginx/html;

    # index: Default file to serve when directory is requested
    # When user visits http://localhost/ (no specific file)
    # nginx automatically serves /usr/share/nginx/html/index.html
    #
    # CAN SPECIFY MULTIPLE (nginx tries in order):
    # index index.html index.htm default.html;
    index index.html;

    # =============================================================
    # LOCATION BLOCK: ROOT / - SPA ROUTING SUPPORT
    # =============================================================
    # This handles ALL requests that don't match other location blocks
    # Critical for React Router and other client-side routing
    location / {
        # try_files: Try to serve files in this order
        # 
        # SYNTAX: try_files file1 file2 ... fallback;
        # 
        # $uri = The requested URI/path
        # $uri/ = The requested URI as a directory
        # /index.html = Fallback if nothing else matches
        #
        # HOW IT WORKS:
        # Request: http://localhost/about
        # 1. Try $uri: /usr/share/nginx/html/about (file doesn't exist)
        # 2. Try $uri/: /usr/share/nginx/html/about/ (directory doesn't exist)
        # 3. Fallback: /usr/share/nginx/html/index.html (✓ serve this!)
        #
        # WHY IS THIS NEEDED FOR REACT?
        # - React Router handles routing in JavaScript (client-side)
        # - Routes like /about, /contact don't exist as actual files
        # - Without this, nginx returns 404 for client-side routes
        # - With this, nginx serves index.html for all routes
        # - React Router then handles the routing in the browser
        #
        # SCENARIOS:
        # 1. User visits http://localhost/
        #    → nginx serves index.html directly
        # 
        # 2. User visits http://localhost/about
        #    → /about file doesn't exist
        #    → nginx serves index.html (fallback)
        #    → React Router sees /about path
        #    → React Router renders About component
        # 
        # 3. User refreshes page on http://localhost/about
        #    → Same as scenario 2 (works correctly!)
        # 
        # WITHOUT try_files:
        # - User visits /about
        # - nginx looks for /about file
        # - File doesn't exist
        # - nginx returns 404 error
        # - Broken user experience!
        try_files $uri $uri/ /index.html;

        # ==========================================================
        # OPTIONAL: Cache Control Headers for Static Files
        # ==========================================================
        # Uncomment to add caching headers for better performance
        # 
        # # HTML files - no caching (always check for updates)
        # location ~* \.html$ {
        #     expires -1;
        #     add_header Cache-Control "no-store, no-cache, must-revalidate, proxy-revalidate";
        # }
        # 
        # # JavaScript and CSS with hashed names - cache forever
        # location ~* \.(js|css)$ {
        #     expires 1y;
        #     add_header Cache-Control "public, immutable";
        # }
        # 
        # # Images and fonts - cache for 1 month
        # location ~* \.(jpg|jpeg|png|gif|svg|ico|woff|woff2|ttf|eot)$ {
        #     expires 1M;
        #     add_header Cache-Control "public";
        # }
    }

    # =============================================================
    # LOCATION BLOCK: /api/ - BACKEND API PROXY
    # =============================================================
    # This forwards all /api/* requests to the backend container
    # This is how frontend and backend communicate in Docker
    location /api/ {
        # ===========================================================
        # proxy_pass: Forward requests to another server
        # ===========================================================
        # SYNTAX: proxy_pass http://upstream-server:port/path;
        #
        # DESTINATION BREAKDOWN:
        # http:// = Protocol (use http inside Docker network)
        # backend = Docker Compose service name (from docker-compose.yml)
        # :4000 = Port backend listens on (from server/index.js)
        # /api/ = Path prefix to forward
        #
        # HOW DOCKER NETWORKING WORKS:
        # - docker-compose creates a network for all services
        # - Each service is accessible by its service name as hostname
        # - "backend" resolves to the backend container's IP
        # - Containers communicate directly within Docker network
        # - No need to go through host machine
        #
        # REQUEST FLOW:
        # 1. Browser → http://localhost/api/message
        # 2. nginx receives request (port 80)
        # 3. nginx sees /api/ prefix
        # 4. nginx forwards to http://backend:4000/api/message
        # 5. Express server responds
        # 6. nginx forwards response back to browser
        #
        # IMPORTANT: Path preservation
        # Request to: /api/message
        # Forwarded to: http://backend:4000/api/message
        # The /api/ prefix is kept!
        #
        # TO REMOVE PREFIX:
        # proxy_pass http://backend:4000/; (with trailing slash)
        # Request to: /api/message
        # Forwarded to: http://backend:4000/message
        proxy_pass http://backend:4000/api/;

        # ===========================================================
        # HTTP VERSION
        # ===========================================================
        # Use HTTP/1.1 for backend communication
        # Required for features like WebSockets and keep-alive connections
        # Default is HTTP/1.0 which doesn't support these features
        proxy_http_version 1.1;

        # ===========================================================
        # PROXY HEADERS - Preserve Client Information
        # ===========================================================
        # When nginx proxies requests, it needs to pass along client info
        # These headers tell backend server about the original request

        # Host header: Original domain requested by client
        # $host = domain name from request (e.g., localhost)
        # Backend sees the correct hostname, not "backend:4000"
        proxy_set_header Host $host;

        # X-Real-IP: Client's actual IP address
        # $remote_addr = IP address of the client
        # Without this, backend would see nginx's IP
        # Useful for logging, rate limiting, geolocation
        proxy_set_header X-Real-IP $remote_addr;

        # X-Forwarded-For: Chain of proxy IPs
        # $proxy_add_x_forwarded_for = client IP + previous proxies
        # If request goes through multiple proxies, this builds a list
        # Format: client-ip, proxy1-ip, proxy2-ip
        # Backend can see the full chain of requests
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

        # ===========================================================
        # ADDITIONAL HEADERS YOU MIGHT NEED
        # ===========================================================
        # Uncomment as needed:

        # X-Forwarded-Proto: Original protocol (http or https)
        # proxy_set_header X-Forwarded-Proto $scheme;

        # X-Forwarded-Host: Original host header
        # proxy_set_header X-Forwarded-Host $host;

        # X-Forwarded-Port: Original port
        # proxy_set_header X-Forwarded-Port $server_port;

        # ===========================================================
        # TIMEOUT SETTINGS
        # ===========================================================
        # Control how long nginx waits for backend responses

        # proxy_connect_timeout: Time to establish connection to backend
        # If backend doesn't respond within 5s, nginx gives up
        # Prevents hanging on dead backend
        proxy_connect_timeout 5s;

        # proxy_read_timeout: Time to wait for backend to send response
        # After connection is established, wait max 60s for response
        # Increase for slow operations (large file uploads, complex queries)
        proxy_read_timeout 60s;

        # ===========================================================
        # MORE TIMEOUT OPTIONS (optional)
        # ===========================================================
        # Uncomment if needed:

        # proxy_send_timeout: Time to send request to backend
        # proxy_send_timeout 60s;

        # ===========================================================
        # BUFFER SETTINGS (optional)
        # ===========================================================
        # Control how nginx buffers proxied responses
        # Uncomment for large responses:

        # proxy_buffering on;
        # proxy_buffer_size 4k;
        # proxy_buffers 8 4k;
        # proxy_busy_buffers_size 8k;

        # ===========================================================
        # WEBSOCKET SUPPORT (if needed)
        # ===========================================================
        # Uncomment for WebSocket connections:
        # proxy_set_header Upgrade $http_upgrade;
        # proxy_set_header Connection "upgrade";

        # ===========================================================
        # ERROR HANDLING
        # ===========================================================
        # Uncomment to show custom error pages:
        # proxy_intercept_errors on;
        # error_page 502 503 504 /50x.html;
    }

    # =============================================================
    # GZIP COMPRESSION - Performance Optimization
    # =============================================================
    # Compress responses before sending to browser
    # Reduces bandwidth usage and speeds up page loads
    
    # gzip on: Enable gzip compression
    # Without this, files are sent uncompressed (larger, slower)
    gzip on;

    # gzip_types: Which file types to compress
    # MIME types listed here will be compressed
    # 
    # WHY THESE TYPES?
    # - text/plain: Plain text files
    # - application/json: API responses (important for /api/ proxy!)
    # - text/css: Stylesheets
    # - application/javascript: JavaScript files
    # - application/octet-stream: Generic binary data
    #
    # NOTE: HTML is always compressed (don't need to list it)
    #
    # COMPRESSION BENEFITS:
    # - JavaScript files: 70-90% size reduction
    # - JSON: 80-95% size reduction
    # - CSS: 60-80% size reduction
    # 
    # EXAMPLE:
    # Uncompressed bundle.js: 500KB
    # Gzipped bundle.js: 100KB (80% reduction!)
    # Faster download, less bandwidth, happier users
    gzip_types text/plain application/json text/css application/javascript application/octet-stream;

    # =============================================================
    # ADDITIONAL GZIP OPTIONS (optional)
    # =============================================================
    # Uncomment for more control:

    # gzip_comp_level: Compression level (1-9)
    # Higher = better compression but slower
    # 6 is good balance (default: 1)
    # gzip_comp_level 6;

    # gzip_vary: Add "Vary: Accept-Encoding" header
    # Tells caches to serve different versions based on compression support
    # gzip_vary on;

    # gzip_min_length: Don't compress files smaller than this
    # Small files aren't worth compressing (overhead > benefit)
    # gzip_min_length 1000;

    # gzip_proxied: When to compress proxied requests
    # gzip_proxied any;

    # gzip_disable: Disable for specific browsers
    # Old IE versions had gzip bugs
    # gzip_disable "msie6";

    # =============================================================
    # SECURITY HEADERS (Recommended for production)
    # =============================================================
    # Uncomment to add security headers:

    # Prevent clickjacking
    # add_header X-Frame-Options "SAMEORIGIN" always;

    # Prevent MIME type sniffing
    # add_header X-Content-Type-Options "nosniff" always;

    # Enable XSS protection
    # add_header X-XSS-Protection "1; mode=block" always;

    # Referrer policy
    # add_header Referrer-Policy "no-referrer-when-downgrade" always;

    # Content Security Policy (customize for your app)
    # add_header Content-Security-Policy "default-src 'self' http: https: data: blob: 'unsafe-inline'" always;

    # =============================================================
    # ACCESS & ERROR LOGS
    # =============================================================
    # By default, nginx logs to:
    # - /var/log/nginx/access.log (all requests)
    # - /var/log/nginx/error.log (errors)
    #
    # View logs:
    # docker exec <container-id> cat /var/log/nginx/access.log
    # docker logs <container-id>
    #
    # Custom log locations:
    # access_log /var/log/nginx/myapp-access.log;
    # error_log /var/log/nginx/myapp-error.log warn;
}

# =================================================================
# TESTING THIS CONFIGURATION
# =================================================================
# 
# 1. Test syntax before deploying:
#    docker exec <container-id> nginx -t
#
# 2. Reload configuration without downtime:
#    docker exec <container-id> nginx -s reload
#
# 3. Check if gzip is working:
#    curl -H "Accept-Encoding: gzip" -I http://localhost
#    Look for "Content-Encoding: gzip" header
#
# 4. Test proxy:
#    curl http://localhost/api/message
#    Should return: {"message": "Hello from chaicode server"}
#
# 5. Test SPA routing:
#    Visit http://localhost/some-fake-route
#    Should serve index.html (not 404)
#
# =================================================================
